# Generation ID Migration Analysis

## Current State

### ID Length Distribution

**Drafts** (289 total):
- 1 legacy (16 chars)
- 49 legacy (17 chars)
- 239 deterministic (18 chars)
- **17% legacy IDs**

**Essays** (258 total):
- 2 legacy (15-16 chars)
- 37 legacy (17 chars)
- 219 deterministic (18 chars)
- **15% legacy IDs**

**Evaluations** (4154 total):
- 1 legacy (15 chars)
- 18 legacy (16 chars)
- 754 legacy (17 chars)
- 3381 deterministic (18 chars)
- **19% legacy IDs**

### ID Format

**Legacy IDs** (pre-migration):
- Variable length: 15-17 characters
- Format: `{stage_prefix}{random_base36}`
- Examples: `e_qllri1vseelbo` (15), `e_7if5p9l5rfl60is` (17), `d_xk3ukesmu6nfmwc` (16)
- Generated by: `reserve_gen_id()` with random/run-based hashing

**Deterministic IDs** (post-migration):
- Fixed length: 18 characters (prefix + 16-char hash)
- Format: `{stage_prefix}{16_char_deterministic_hash}`
- Examples: `e_1hbnjo1jogt1adhn`, `d_2482bhj4oqmqx14u`, `v_1bqaqds1zjbj7bc`
- Generated by: `compute_deterministic_gen_id()` from stage-specific signatures (drafts use combo/template/model/replicate; essays use parent draft/template/replicate; evaluations use parent essay/template/model/replicate)

## The Parent ID Problem

The core challenge is that **gen_ids are used as parent_gen_ids in child generations**:

```
Draft (d_xk3ukesmu6nfmwc - legacy ID)
  └─> Essay (e_qllri1vseelbo - legacy ID)
        └─> Evaluation (v_r6h5h0w94rzst35 - legacy ID)
              parent_gen_id: "e_qllri1vseelbo"
```

If we migrate an essay ID from `e_qllri1vseelbo` → `e_<new_deterministic>`, we must:
1. Rename the directory: `data/gens/essay/e_qllri1vseelbo/` → `data/gens/essay/e_<new>/`
2. Update the essay's metadata `gen_id` field
3. Update ALL child evaluations' `parent_gen_id` field to reference the new ID
4. Update the essay's parent draft `gen_id` in the essay metadata

This creates a **cascading update problem**.

## Why We Can't Just Recompute IDs

The deterministic ID system requires specific metadata to compute IDs:

### Draft ID Signature
```python
draft_signature(combo_id, draft_template_id, generation_model_id, replicate_index)
```

### Essay ID Signature
```python
essay_signature(draft_gen_id, essay_template_id, replicate_index)
```

### Evaluation ID Signature
```python
evaluation_signature(essay_gen_id, evaluation_template_id, evaluation_model_id, replicate_index)
```

**Problem**: Essay signatures depend on `draft_gen_id`, and evaluation signatures depend on `essay_gen_id`. If we migrate a draft ID, all downstream essay and evaluation IDs change too.

## Migration Complexity Analysis

### Simple Case: Evaluations Only

If we only migrate evaluation IDs:
- ✅ No children to update (evaluations are leaves)
- ❌ Still need to update parent essays' references (if they point to evaluations anywhere)
- ❌ Lose ability to deterministically regenerate the same evaluation ID later

### Moderate Case: Essays + Evaluations

If we migrate essays and evaluations:
- ✅ Essays are migrated to deterministic IDs
- ❌ Must update all evaluation `parent_gen_id` fields
- ❌ Essay deterministic IDs will be based on legacy draft IDs
- ❌ Not truly deterministic until drafts are also migrated

### Complete Case: All Generations

If we migrate all three stages:
1. **Migrate drafts first**
   - Update draft `gen_id` in metadata
   - Rename draft directories
   - Update all child essays' `parent_gen_id`

2. **Migrate essays second**
   - Compute new essay IDs based on NEW draft IDs
   - Update essay `gen_id` in metadata
   - Rename essay directories
   - Update all child evaluations' `parent_gen_id`

3. **Migrate evaluations last**
   - Compute new evaluation IDs based on NEW essay IDs
   - Update evaluation `gen_id` in metadata
   - Rename evaluation directories
   - No children to update

## Required Metadata for Migration

To compute deterministic IDs, we need this metadata for each generation:

### For Drafts
```json
{
  "template_id": "gwern_original",
  "llm_model_id": "gemini_25_pro",
  "replicate": 1
}
```

### For Essays
```json
{
  "parent_gen_id": "d_<new_draft_id>",  // Updated after draft migration
  "template_id": "parsed-from-links-v1",
  "replicate": 1
}
```

### For Evaluations
```json
{
  "parent_gen_id": "e_<new_essay_id>",  // Updated after essay migration
  "template_id": "novelty",
  "llm_model_id": "sonnet-4",
  "replicate": 1
}
```

**Status Check (2025-02-XX)**

We re-ran an exhaustive audit over `data/gens/**/metadata.json` and confirmed that drafts, essays, and evaluations now contain every field required to compute deterministic IDs. Essays no longer persist `combo_id` directly; when needed we derive it from the parent draft during migration/analysis. Evaluations already load their combo from the parent chain as well. No additional backfill is required.

## Migration Strategy Options

### Option 1: Leave Legacy IDs As-Is (Current State)
**Pros:**
- No work required
- No risk of data corruption
- System works fine with mixed ID formats

**Cons:**
- Inconsistent ID lengths
- Cannot deterministically regenerate legacy generations
- Confusing for developers

**Recommendation**: ✅ **This is acceptable** unless there's a specific reason to migrate.

### Option 2: Migrate Only New Cohorts Going Forward
**Pros:**
- Clean boundary between old and new
- No risky data migration
- New work uses deterministic IDs

**Cons:**
- Still have legacy IDs forever
- Backfill cohorts mix formats

**Recommendation**: ✅ **Already happening** - new cohorts use deterministic IDs.

### Option 3: Full Migration Script
**Pros:**
- Complete consistency
- Fully deterministic ID space

**Cons:**
- High complexity
- Risk of data corruption
- Must handle missing metadata
- Must update Dagster partition registry
- Time-consuming (4000+ generations)

**Recommendation**: ⚠️ **Only if absolutely necessary** - cost/benefit is poor.

## Recommended Approach: Accept Mixed IDs

**Rationale:**
1. The system already handles both ID formats correctly
2. Legacy IDs are ~17% of the data and decreasing
3. No functional problems with mixed formats
4. Migration risk outweighs benefits

**Actions:**
1. ✅ Document that legacy IDs exist and why (this file)
2. ✅ Ensure all code handles variable-length IDs (already does)
3. ✅ Continue using deterministic IDs for all new generations (already happening)
4. ✅ Add validation that new generations use 18-character IDs

## If Migration Is Required

If you absolutely must migrate, here's the approach:

### Phase 1: Inventory & Validation
```bash
# Script to validate all metadata has required fields
python scripts/validate_migration_metadata.py
```

### Phase 2: Draft Migration
```python
# For each draft with legacy ID:
# 1. Compute new ID from metadata
# 2. Rename directory
# 3. Update metadata gen_id
# 4. Find all child essays, update their parent_gen_id
# 5. Log mapping: old_id -> new_id
```

### Phase 3: Essay Migration
```python
# For each essay with legacy ID:
# 1. Look up parent draft's NEW ID from phase 1 mapping
# 2. Compute new essay ID using new parent draft ID
# 3. Rename directory
# 4. Update metadata gen_id and parent_gen_id
# 5. Find all child evaluations, update their parent_gen_id
# 6. Log mapping: old_id -> new_id
```

### Phase 4: Evaluation Migration
```python
# For each evaluation with legacy ID:
# 1. Look up parent essay's NEW ID from phase 2 mapping
# 2. Compute new evaluation ID using new parent essay ID
# 3. Rename directory
# 4. Update metadata gen_id and parent_gen_id
# 5. Log mapping: old_id -> new_id
```

### Phase 5: Update Dagster Partitions
```python
# Remove old partition keys, add new partition keys
for old_id, new_id in evaluation_mappings.items():
    instance.delete_dynamic_partition("evaluation_gens", old_id)
    instance.add_dynamic_partitions("evaluation_gens", [new_id])
```

### Phase 6: Update Cross-References
- Update any `data/7_cross_experiment/` CSV files that reference gen_ids
- Update any cohort membership files
- Update any selection files

## Conclusion

**Recommendation: Do NOT migrate legacy IDs unless there's a compelling functional reason.**

The current mixed-ID situation is:
- ✅ Functionally correct
- ✅ Low maintenance burden
- ✅ Decreasing over time naturally
- ❌ Slightly confusing aesthetically

A full migration is:
- ❌ High risk
- ❌ High complexity
- ❌ Time-consuming
- ✅ Provides marginal aesthetic benefit

**Decision**: Accept mixed IDs as a historical artifact and move forward with deterministic IDs for all new work.
