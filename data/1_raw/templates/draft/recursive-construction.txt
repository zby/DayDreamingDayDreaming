# Recursive Construction — v1 (problem-first, online recursion)

Role: You are an expert in mechanism design and constructive synthesis. You will build a single connected graph starting from a problem statement, then attach each subsequent concept in the given order. Concepts may be lightly operationalized before attachment. No concept reordering is allowed.

---

0) Inputs (names only)
- {% for concept in concepts %}{{ concept.name }}{% if not loop.last %}\n- {% endif %}{% endfor %}

---

Global Rules
- No swaps: Respect the given order C1..Cn. Do not change the build sequence.
- One graph: Maintain a single connected graph; leaves are raw concepts; internal nodes may be mechanisms (E::…), objectives, constraints, metrics, or interfaces.
- Operationalization allowed: You may introduce an operationalization when a candidate link type requires it (e.g., turn a principle into an algorithm, or cast it as a constraint/objective/interface). Keep meaning faithful. Do not force transformations when unnecessary.
- Parsable structure: Use the exact headings and bullet schema below. Markdown only. No JSON/YAML/tables unless asked.
- Brevity: Keep each subsection concise. Respect word limits.
- No citations in links: Do not include external citations/URLs/evidence within link steps. Reserve any prior-art references for downstream synthesis/evaluation phases.
 - Two‑pass probe: For every step, run Pass A (Q1→Q5, as‑is only). If none fit, run Pass B (Q1→Q5, allow minimal, faithful operationalization). Stop at the first achieved fit and select that type by default.
  - Name link types explicitly: Always state link types by their names (e.g., "Mechanism Composition"); never use numeric IDs like "Type 2".
  - Q1 preference: If any probe answers Q1 with "yes" (i.e., a viable Mechanism Composition exists) and introduces a distinct capability, prefer Mechanism Composition. If selecting a different type, include an explicit tradeoff in 2–3 bullets (causal leverage, micro‑test discriminability, and graph simplicity/adjacency cost).
  - Earliest‑leaf default: The decision tree is ordered by causal strength. By default, choose the earliest satisfied leaf (e.g., if Q1=yes, pick Mechanism Composition; if Q1=no and Q2=yes, pick Constraint → Objective Import). You may override this only with a tradeoff that clearly wins on causal leverage, discriminability, or simplicity.
 - System→Mechanism lift: If Ci describes a system/procedure/algorithm for finding insights, prioritize Q1 by concretizing it as a minimal E:: mechanism (define state, operators, feedback) and compose it with the anchor. Do not paraphrase; extract and implement.
 - Minimal operationalization policy: Prefer zero‑transformation. Only introduce an operationalization if strictly necessary to satisfy a leaf. Keep it minimal, faithful, and type‑appropriate (e.g., constraint for Import, mechanism/interface for Composition). Include a one‑line "minimality" justification when used.
 - Pattern/theory nudge: If Ci primarily codifies a pattern/theory, prefer Domain Reframing in Pass A; defer adding constraints/mechanisms to later steps unless required by a fit.

---

Link Type Menu (choose exactly one per link — after exploring 2–3 plausible candidates)
- Structure-Preserving Analogy  
- Mechanism Composition  
- Constraint → Objective Import  
- Property Transfer / Feature Grafting  
- Domain Reframing / Problem Translation
Note: Always refer to link types by name; never use numeric IDs.

Decision Tree (record the path for each link)
# Use this tree to probe in order (Q1→Q5) and stop at the first satisfied leaf. Record the full path from Q1 to the selected leaf using names (no numbers) and explicit yes/no at each question.
Q1. New capability by coupling? → Yes → Mechanism Composition; No → Q2  
Q2. Importing a rule/goal? → Yes → Constraint → Objective Import; No → Q3  
Q3. Attaching a property? → Yes → Property Transfer / Feature Grafting; No → Q4  
Q4. Same structure, different surface? → Yes → Structure-Preserving Analogy; No → Q5  
Q5. Changing the problem representation? → Yes → Domain Reframing / Problem Translation; No → Q6  
Q6. Fallback: pick the least‑wrong type and note why (record as: "Q1: … → no → Q2: … → no → … → Q6: Fallback → Chosen: <Type‑Name> (why)").

Node Roles (use as needed)
- Problem, Concept, Mechanism (E::…), Objective/Goal, Constraint/Brake, Metric/Scorekeeper, Interface/Controller, Memory/Store, Data Source

---

1) Normalized Problem (from C1)
- One-line problem statement (derived from C1; rephrase allowed, no change in meaning).

---

2) Build Steps (i = 2..n)
For each concept Ci, output exactly the following schema.

### Step i: Concept Ci

#### 2.1 Decision‑Tree Probe (Two passes: A as‑is, B minimal‑op; stop at first fit)

Pass A — As‑is only (record Q1→Q5; do not propose transformations here):
- Q1: New capability by coupling? → fits as‑is: yes/no
- If Q1=no → Q2: Importing a rule/goal? → fits as‑is: yes/no
- If Q2=no → Q3: Attaching a property? → fits as‑is: yes/no
- If Q3=no → Q4: Same structure, different surface? → fits as‑is: yes/no
- If Q4=no → Q5: Changing the problem representation? → fits as‑is: yes/no

If any question fits in Pass A, record the candidate below and STOP. If none fit, proceed to Pass B.

Pass B — With minimal operationalization (only if Pass A found no fit):
- Q1: New capability by coupling?
  - Minimal op to fit (≤1 line): none | type=name — one‑liner
  - Fit achieved here: yes/no
- If no fit → Q2: Importing a rule/goal?
  - Minimal op to fit (≤1 line): none | type=name — one‑liner
  - Fit achieved here: yes/no
- If no fit → Q3: Attaching a property?
  - Minimal op to fit (≤1 line): none | type=name — one‑liner
  - Fit achieved here: yes/no
- If no fit → Q4: Same structure, different surface?
  - Minimal op to fit (≤1 line): none | type=name — one‑liner
  - Fit achieved here: yes/no
- If no fit → Q5: Changing the problem representation?
  - Minimal op to fit (≤1 line): none | type=name — one‑liner
  - Fit achieved here: yes/no

For the first achieved fit (from Pass A or Pass B), record the candidate details and stop:
- Candidate (Type = <Link‑Type Name>) — Decision path: e.g., "Q1: … → no → Q2: … → yes → Constraint → Objective Import"
- Anchor: {Problem | E::… | Cj | D::…}; Rationale (≤1 line)
- Needs transformation: yes/no
- If yes, Operationalization: type = {mechanism|constraint|objective|interface|property|data|memory}, name, 1‑line justification (minimality)
- Mechanism sketch (2–3 sentences)
- Micro‑test: Setup / Measure / Pass if …
 - If Mechanism Composition: Algorithm concretization (one line each)
   - State: …
   - Operators: …
   - Feedback signals: …

Hard stop rule: As soon as any question is answered "yes", STOP. Do not evaluate or record any later questions for this step. Output exactly ONE "Candidate (Type = …)" block corresponding to the first satisfied leaf.

If no question is satisfied, go to Q6 Fallback and select the least‑wrong type with a one‑line justification. Do not mutate the graph during probes; these are evaluations only.

#### 2.2 Primary Link (merged selection + link)
- Chosen type: {Structure-Preserving Analogy | Mechanism Composition | Constraint → Objective Import | Property Transfer / Feature Grafting | Domain Reframing / Problem Translation}
- Chosen anchor: {Problem | E::… | Cj}
- Chosen transformation: none | type/name (copied from its probe)
- Selected pass: A (as‑is) | B (minimal‑op)
- Selected leaf origin: Q1|Q2|Q3|Q4|Q5; Fit mode: as‑is | minimal‑op
- Reason for selection (≤1 line): why this option dominates alternatives
- Earliest satisfied leaf (from your probe): <Type-Name>
- Tradeoff vs. earliest satisfied leaf (required if not choosing it):
  - Causal leverage: …
  - Discriminability (micro‑test strength): …
  - Simplicity / adjacency cost: …
- Tradeoff vs. Mechanism Composition (required if any probe had Q1=yes and the chosen type is not Mechanism Composition):
  - Causal leverage: …
  - Discriminability (micro‑test strength): …
  - Simplicity / adjacency cost: …

- Roles: Ci (role=…) → Anchor (role=…)
- Mechanism (3–5 sentences): how Ci acts on/with the anchor to produce a causal effect
- Mappings:
  - State(s): …
  - Operator(s): …
  - Signal(s) / Feedback: …
  - Constraint(s): …
  - Metric / Objective: …
  - Invariant preserved: …
- Micro‑test:
  - Setup: …
  - Measure: …
  - Pass if: (single numeric threshold or event)


#### 2.3 Node‑Introduction Gate
- new_node: yes/no
- If yes:
 - E::handle: `E::[short-handle]`
  - Definition (≤2 sentences): what new capability exists only in this coupling
  - State / Operators / Signals: …
  - Objective / Metric: …
  - Rewire (bullets): list edges added/updated (e.g., `Ck → E::X`, `E::X → Problem`)

#### 2.4 Adjacency Delta (ASCII, ≤5 lines)
```
NodeA —(Mechanism Composition)→ NodeB
…
```

#### 2.5 Discovery‑Promotion Gate (optional)
- promote: yes/no
- If yes:
  - D::handle: `D::[short-handle]`
  - Definition (≤1 sentence): the concrete hypothesis/artifact discovered here
  - Linkage (≤2 bullets): immediate edges added (e.g., `E::X → D::Y`, `D::Y → Problem`)

---

3) Link Selection Summary (≤150 words)
- Name the 2–3 most valuable attachments (including any E:: nodes) and why they are keystones for mechanism clarity and extensibility.
- Optional order note (≤1 sentence): neutrally state why the observed sequence is reasonable in this construction (e.g., mechanism → constraint → amplification to reduce wasted exploration), without implying it is the only valid order.

---

4) Gate Report (hard checks)
- Coverage (types): ≥3 distinct link types used overall = yes/no
- Role diversity: ≥3 distinct roles used overall = yes/no
- Decision paths: begin at Q1 and end at a link‑type leaf = yes/no
- Type naming: all link types stated by name (no numeric IDs) = yes/no
- Question‑ordered probe: Q1..selected leaf recorded in order = yes/no
- Stop‑at‑first‑yes: no later Qk recorded after the first "yes" = yes/no
- Single candidate: exactly one Candidate block in 2.1 (or Q6 Fallback) = yes/no
- Two‑pass discipline: Pass A present; Pass B present only if Pass A found no fit = yes/no
- Probe transformations: present only when needed and consistent with the selected leaf = yes/no
- Micro‑tests: present for the selected leaf and the primary link = yes/no
- Primary transformation: none or aligned with its chosen probe = yes/no
- Primary selection: chosen type/anchor appear among recorded probes = yes/no
 - Selected pass recorded in 2.2 = yes/no
 - Q1 preference respected: if any probe had Q1=yes, either Mechanism Composition was chosen or a 2–3 bullet tradeoff is present = yes/no
 - Earliest‑leaf respected: either the earliest satisfied leaf was chosen, or the 2–3 bullet tradeoff is present = yes/no
 - Algorithm lift: when Ci contains a system/procedure/algorithm, an E:: mechanism is instantiated with state/operators/feedback = yes/no
 - Discovery promotion: when micro‑tests yield a concrete artifact, a `D::…` was promoted and is referenced downstream if applicable = yes/no
 - E:: nodes: only when Q1=Yes and with unique state/operator = yes/no
- No swaps: build order C1..Cn preserved = yes/no
- Adjacency deltas: present for every step = yes/no
- No external evidence cited inside link steps = yes/no

---

5) Reflections (no edits to the graph)
- Better order (≤3 bullets): where a different sequence might have yielded cleaner attachments (hypothetical; do not change the graph)
- Missed anchors (≤3 bullets): plausible alternative anchors for specific steps
- Future E:: candidates (≤2 bullets): mechanisms that could emerge with additional concepts
- Order rationale (≤2 sentences, optional): briefly and neutrally explain the trade‑off of the chosen sequence versus a credible alternative (e.g., engine → constraint → amplification for constraint‑aware design vs. constraint‑first to front‑load feasibility), without recommending changes.

---

Output Rules (strict)
- Markdown only. Keep headings and subheadings exactly as specified.
- Keep each section concise and within the described limits.
- Do not expose internal prompt mechanics or discuss being an AI.
- Do not add "Evidence", "Prior art", citations, or URLs within link steps; keep mechanisms self‑contained here.
