The generator–verifier gap describes problems with an efficiently computable quality test q(x) (or predicate) where sampling arbitrary x and evaluating q(x) are cheap, yet sampling only from the acceptable set S={x:q(x)≥τ} without propose-and-filter search is expensive. Intuitively, both "generate" (produce diverse candidates) and "verify" (quickly score or reject a given candidate) are easy operations, but aiming the generator so that almost everything it emits already satisfies q is hard. The gap's size can be thought of as the extra computation required to hit S compared with just proposing and verifying. This motivates generator-plus-critic architectures and underlies examples like proof search, program synthesis, cryptographic preimage search, and hypothesis generation.